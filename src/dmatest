#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/usart.h>
#include <libopencm3/stm32/dma.h>
#include <libopencm3/cm3/nvic.h>

#define BUFFER_SIZE 16

// Буфер для данных
uint8_t tx_buffer[BUFFER_SIZE] = "Hello World!\r\n";
volatile bool dma_transfer_complete = false;

void rcc_setup(void) {
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_USART2);
    rcc_periph_clock_enable(RCC_DMA1);
}

void gpio_setup(void) {
    // Настройка TX пина (PA2) для USART2
    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ, 
                  GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART2_TX);
}

void usart_setup(void) {
    usart_set_baudrate(USART2, 115200);
    usart_set_databits(USART2, 8);
    usart_set_stopbits(USART2, USART_STOPBITS_1);
    usart_set_parity(USART2, USART_PARITY_NONE);
    usart_set_flow_control(USART2, USART_FLOWCONTROL_NONE);
    usart_set_mode(USART2, USART_MODE_TX);
    
    // Включение DMA для USART
    // USART_CR3(USART2) |= USART_CR3_DMAT;

    usart_enable_tx_dma(USART2);
    
    usart_enable(USART2);
}

void dma_setup(void) {
    // Сброс и настройка DMA канала 7 для USART2_TX
    dma_channel_reset(DMA1, DMA_CHANNEL7);
    
    dma_set_peripheral_address(DMA1, DMA_CHANNEL7, (uint32_t)&USART2_DR);
    dma_set_memory_address(DMA1, DMA_CHANNEL7, (uint32_t)tx_buffer);
    dma_set_number_of_data(DMA1, DMA_CHANNEL7, BUFFER_SIZE);
    
    dma_set_read_from_memory(DMA1, DMA_CHANNEL7);
    dma_enable_memory_increment_mode(DMA1, DMA_CHANNEL7);
    dma_set_peripheral_size(DMA1, DMA_CHANNEL7, DMA_CCR_PSIZE_8BIT);
    dma_set_memory_size(DMA1, DMA_CHANNEL7, DMA_CCR_MSIZE_8BIT);
    dma_set_priority(DMA1, DMA_CHANNEL7, DMA_CCR_PL_LOW);
    
    // Включение прерывания по завершению передачи
    dma_enable_transfer_complete_interrupt(DMA1, DMA_CHANNEL7);
    
    // Разрешение прерывания DMA
    nvic_enable_irq(NVIC_DMA1_CHANNEL7_IRQ);
}

// Обработчик прерывания DMA
void dma1_channel7_isr(void) {
    if (dma_get_interrupt_flag(DMA1, DMA_CHANNEL7, DMA_TCIF)) {
        dma_clear_interrupt_flags(DMA1, DMA_CHANNEL7, DMA_TCIF);
        dma_transfer_complete = true;
    }
}

void start_dma_transfer(void) {
    dma_disable_channel(DMA1, DMA_CHANNEL7);
    dma_set_number_of_data(DMA1, DMA_CHANNEL7, BUFFER_SIZE);
    dma_clear_interrupt_flags(DMA1, DMA_CHANNEL7, DMA_TCIF);
    dma_enable_channel(DMA1, DMA_CHANNEL7);
}

int main(void) {
    rcc_setup();
    gpio_setup();
    usart_setup();
    dma_setup();
    
    // Запуск первой передачи
    start_dma_transfer();

    while (1) {
        // Если передача завершена, готовим новые данные и запускаем снова
        if (dma_transfer_complete) {
            dma_transfer_complete = false;
            
            // Здесь можно добавить код для чтения новых данных от датчика
            // и заполнения буфера tx_buffer
            
            // Запуск следующей передачи
            start_dma_transfer();
        }
        
        // Небольшая задержка между передачами
        for (volatile int i = 0; i < 100000; i++);
    }
}

======================
/* Напишем отладочную программу с использованием двух устройств. Будем отправлять числа
 * с одного устройства и принимать с другого. Последнее будет выводить принятые
 * и обработанные данные в UART.
 * При каждом принятом числе посредством DMA будем отображать информацию*/

#include <libopencm3/stm32/timer.h>
#include <libopencm3/cm3/nvic.h>
#include <libopencm3/stm32/dma.h>
#include <libopencm3/stm32/usart.h>

#include "test/setup.hpp"

// Глобальный флаг для отслеживания завершения передачи
volatile bool transfer_complete = 1;
const uint8_t tx_len = 4;
char tx[tx_len] = "a\n\r";


void start_dma_transfer(void) { 
    if (transfer_complete) { 
        transfer_complete = 0;
        
        tx[0]++;
        if (tx[0] > 'z') tx[0] = 'a';
        
        // Перезапускаем DMA передачу
        dma_disable_channel(DMA1, DMA_CHANNEL7);
        dma_set_number_of_data(DMA1, DMA_CHANNEL7, tx_len);
        dma_set_memory_address(DMA1, DMA_CHANNEL7, (uint32_t)tx);

		dma_enable_transfer_complete_interrupt(DMA1, DMA_CHANNEL7);

        dma_enable_channel(DMA1, DMA_CHANNEL7);
        usart_enable_tx_dma(USART2);
    }
}

// Обработчик прерывания таймера
void tim2_isr(void)
{
    if (timer_get_flag(TIM2, TIM_SR_UIF)) {
        timer_clear_flag(TIM2, TIM_SR_UIF);
        
        // Запускаем передачу по DMA
        start_dma_transfer();
    }
}

void dma1_channel7_isr(void)
{
	// проверяем флаг завершения передачи
	 if (dma_get_interrupt_flag(DMA1, DMA_CHANNEL7, DMA_TCIF)) {
        dma_clear_interrupt_flags(DMA1, DMA_CHANNEL7, DMA_TCIF);
        transfer_complete = 1;

		// отключаем прерывание по завершению передачи для канала 7
		dma_disable_transfer_complete_interrupt(DMA1, DMA_CHANNEL7);

		// отключаем режим DMA для передачи через USART2
		usart_disable_tx_dma(USART2);

		// полностью отключаем канал 7 DMA1
		dma_disable_channel(DMA1, DMA_CHANNEL7);
	}
}

int main(void)
{
	clock_setup();
	uart_setup();
	timer_setup();
	DMA_CH7_USART2_TX_Setup(tx, tx_len);

	//tx[0] = 'a';

	while (1) {
		for (volatile int i = 0; i < 100000; i++);
	}

	return 0;
}